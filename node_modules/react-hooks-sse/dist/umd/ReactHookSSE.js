(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReactHookSSE = {}, global.React));
})(this, (function (exports, React) { 'use strict';

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  }

  var React__namespace = /*#__PURE__*/_interopNamespace(React);

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var createSourceManager = function createSourceManager(createSource) {
    var state = {
      source: null,
      listenersByName: new Map()
    };
    return {
      addEventListener: function addEventListener(name, listener) {
        if (!state.listenersByName.size) {
          state.source = createSource();
        }

        if (!state.source) {
          throw new Error("The source doesn't exist");
        }

        var listeners = state.listenersByName.get(name) || new Set();
        listeners.add(listener);
        state.listenersByName.set(name, listeners);
        state.source.addEventListener(name, listener);
      },
      removeEventListener: function removeEventListener(name, listener) {
        if (!state.source) {
          throw new Error("The source doesn't exist");
        }

        var listeners = state.listenersByName.get(name) || new Set();
        listeners.delete(listener);

        if (!listeners.size) {
          state.listenersByName.delete(name);
        }

        state.source.removeEventListener(name, listener);

        if (!state.listenersByName.size) {
          state.source.close();
          state.source = null;
        }
      }
    };
  };

  var _excluded = ["children"];
  var SSEContext = React__namespace.createContext(null);
  var SSEConsumer = SSEContext.Consumer;

  var isPropsWithSource = function isPropsWithSource(_) {
    return 'source' in _;
  };

  var createDefaultSource = function createDefaultSource(endpoint) {
    return function () {
      return new window.EventSource(endpoint);
    };
  };

  var SSEProvider = function SSEProvider(_ref) {
    var children = _ref.children,
        props = _objectWithoutProperties(_ref, _excluded);

    var _React$useState = React__namespace.useState(function () {
      return createSourceManager(!isPropsWithSource(props) ? createDefaultSource(props.endpoint) : props.source);
    }),
        _React$useState2 = _slicedToArray(_React$useState, 1),
        source = _React$useState2[0];

    return React__namespace.createElement(SSEContext.Provider, {
      value: source
    }, children);
  };

  function useSSE(eventName, initialState, options) {
    var _ref = options || {},
        _ref$stateReducer = _ref.stateReducer,
        stateReducer = _ref$stateReducer === void 0 ? function (_, action) {
      return action.data;
    } : _ref$stateReducer,
        _ref$parser = _ref.parser,
        parser = _ref$parser === void 0 ? function (data) {
      return JSON.parse(data);
    } : _ref$parser,
        _ref$context = _ref.context,
        context = _ref$context === void 0 ? SSEContext : _ref$context;

    var source = React.useContext(context);

    var _useReducer = React.useReducer(stateReducer, initialState),
        _useReducer2 = _slicedToArray(_useReducer, 2),
        state = _useReducer2[0],
        dispatch = _useReducer2[1];

    if (!source) {
      throw new Error('Could not find an SSE context; You have to wrap useSSE() in a <SSEProvider>.');
    }

    React.useEffect(function () {
      var listener = function listener(event) {
        var data = parser(event.data);
        dispatch({
          event: event,
          data: data
        });
      };

      source.addEventListener(eventName, listener);
      return function () {
        source.removeEventListener(eventName, listener);
      };
    }, []);
    return state;
  }

  exports.SSEConsumer = SSEConsumer;
  exports.SSEContext = SSEContext;
  exports.SSEProvider = SSEProvider;
  exports.useSSE = useSSE;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=ReactHookSSE.js.map
